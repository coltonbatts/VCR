use std::fmt::Write as _;
use std::fs;
use std::path::Path;

use anyhow::{anyhow, bail, Context, Result};
use fontdue::Font;

const ASCII_START: u8 = 0x20;
const ASCII_END: u8 = 0x7E;
const GLYPH_WIDTH: usize = 16;
const GLYPH_HEIGHT: usize = 16;
const FONT_SIZE: f32 = 16.0;
const ALPHA_THRESHOLD: u8 = 96;

#[derive(Debug, Clone, Copy)]
struct VariantSpec {
    const_name: &'static str,
    font_path: &'static str,
}

const VARIANTS: [VariantSpec; 5] = [
    VariantSpec {
        const_name: "GEIST_PIXEL_REGULAR",
        font_path: "assets/fonts/geist_pixel/GeistPixel-Line.ttf",
    },
    VariantSpec {
        const_name: "GEIST_PIXEL_MEDIUM",
        font_path: "assets/fonts/geist_pixel/GeistPixel-Square.ttf",
    },
    VariantSpec {
        const_name: "GEIST_PIXEL_BOLD",
        font_path: "assets/fonts/geist_pixel/GeistPixel-Grid.ttf",
    },
    VariantSpec {
        const_name: "GEIST_PIXEL_LIGHT",
        font_path: "assets/fonts/geist_pixel/GeistPixel-Circle.ttf",
    },
    VariantSpec {
        const_name: "GEIST_PIXEL_MONO",
        font_path: "assets/fonts/geist_pixel/GeistPixel-Triangle.ttf",
    },
];

fn main() -> Result<()> {
    let mut output = String::new();
    writeln!(
        &mut output,
        "// @generated by `cargo run --bin generate_ascii_atlas`\n// Do not edit by hand.\n"
    )?;
    writeln!(
        &mut output,
        "pub const ASCII_START: u8 = 0x{ASCII_START:02X};"
    )?;
    writeln!(&mut output, "pub const ASCII_END: u8 = 0x{ASCII_END:02X};")?;
    writeln!(&mut output, "pub const GLYPH_WIDTH: u32 = {GLYPH_WIDTH};")?;
    writeln!(&mut output, "pub const GLYPH_HEIGHT: u32 = {GLYPH_HEIGHT};")?;
    writeln!(&mut output, "pub type GlyphRows = [u16; {GLYPH_HEIGHT}];")?;
    writeln!(
        &mut output,
        "pub const GLYPH_COUNT: usize = {};",
        (ASCII_END - ASCII_START + 1) as usize
    )?;

    for variant in VARIANTS {
        let glyphs = rasterize_variant(variant)?;
        write_variant(&mut output, variant.const_name, &glyphs)?;
    }

    let out_path = Path::new("src/ascii_atlas_data.rs");
    fs::write(out_path, output)
        .with_context(|| format!("failed writing {}", out_path.display()))?;
    println!("wrote {}", out_path.display());
    Ok(())
}

fn rasterize_variant(variant: VariantSpec) -> Result<Vec<[u16; GLYPH_HEIGHT]>> {
    let font_bytes = fs::read(variant.font_path)
        .with_context(|| format!("failed reading {}", variant.font_path))?;
    let font = Font::from_bytes(font_bytes, fontdue::FontSettings::default())
        .map_err(|error| anyhow!("failed parsing {}: {error}", variant.font_path))?;

    let mut glyphs = Vec::with_capacity((ASCII_END - ASCII_START + 1) as usize);

    for codepoint in ASCII_START..=ASCII_END {
        let character = codepoint as char;
        let (metrics, bitmap) = font.rasterize(character, FONT_SIZE);
        if metrics.width > GLYPH_WIDTH || metrics.height > GLYPH_HEIGHT {
            bail!(
                "{} glyph '{}' is {}x{} which exceeds {}x{} atlas cell",
                variant.font_path,
                character,
                metrics.width,
                metrics.height,
                GLYPH_WIDTH,
                GLYPH_HEIGHT
            );
        }

        let offset_x = (GLYPH_WIDTH.saturating_sub(metrics.width)) / 2;
        let offset_y = (GLYPH_HEIGHT.saturating_sub(metrics.height)) / 2;

        let mut rows = [0_u16; GLYPH_HEIGHT];
        for y in 0..metrics.height {
            for x in 0..metrics.width {
                let alpha = bitmap[y * metrics.width + x];
                if alpha < ALPHA_THRESHOLD {
                    continue;
                }

                let atlas_x = offset_x + x;
                let atlas_y = offset_y + y;
                rows[atlas_y] |= 1_u16 << atlas_x;
            }
        }
        glyphs.push(rows);
    }

    Ok(glyphs)
}

fn write_variant(
    output: &mut String,
    const_name: &str,
    glyphs: &[[u16; GLYPH_HEIGHT]],
) -> Result<()> {
    writeln!(
        output,
        "\npub const {const_name}: [GlyphRows; GLYPH_COUNT] = ["
    )?;
    for glyph in glyphs {
        write!(output, "    [")?;
        for (index, row) in glyph.iter().enumerate() {
            if index > 0 {
                write!(output, ", ")?;
            }
            write!(output, "0x{row:04X}")?;
        }
        writeln!(output, "],")?;
    }
    writeln!(output, "];\n")?;
    Ok(())
}
